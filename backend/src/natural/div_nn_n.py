from typing import Self

class DIV_NN_N:
    def DIV_NN_N(self: Self, second: Self) -> Self:
        """
        Автор: Viktor Permitin
        Неполное частное от деления первого
        натурального числа на второе с
        остатком (делитель отличен от нуля)
        
        Параметры:
            self: Self - делимое натуральное число
            second: Self - делитель натуральное число (не равен нулю)
        
        Возвращает:
            Self - неполное частное (целая часть от деления self на second)
        
        Алгоритм:
            Реализует алгоритм деления "в столбик" для длинных чисел.
            
            1. Проверяем деление на ноль
            2. Обрабатываем частные случаи:
               - Если делимое < делителя, результат = 0
               - Если делимое == делителя, результат = 1
            3. Определяем максимальную степень k_max для начала деления
               (разница в количестве разрядов)
            4. Для каждой позиции k от k_max до 0:
               a) Находим цифру частного на позиции k с помощью DIV_NN_DK
               b) Если цифра > 0, вычитаем из остатка произведение делителя
                  на 10^k, умноженное на найденную цифру
               c) Добавляем цифру в результат (пропускаем ведущие нули)
            5. Удаляем ведущие нули из результата
            6. Возвращаем частное
        
        Примеры:
            DIV_NN_N(1234, 12) = 102 (1234 = 12 * 102 + 10)
            DIV_NN_N(100, 10) = 10
            DIV_NN_N(5, 10) = 0
        
        Используется в:
            - MOD_NN_N (остаток от деления)
            - LCM_NN_N (НОК через НОД)
            - DIV_ZZ_Z (деление целых чисел)
            - RED_Q_Q (сокращение дроби)
        
        Примечание:
            Метод вычисляет только целую часть частного. Для получения остатка
            используйте MOD_NN_N или вычислите: remainder = self - second * quotient
        """
        # Проверка деления на ноль
        if len(second.digits) == 1 and second.digits[0] == 0:
            raise ValueError("division by zero")
    
        # Сравниваем делимое и делитель
        # cmp_result: 2 - self > second, 0 - self == second, 1 - self < second
        cmp_result = self.COM_NN_D(second)
        
        # Если делимое меньше делителя, частное равно 0
        if cmp_result == 1:
            return self.__class__([0])
        
        # Если делимое равно делителю, частное равно 1
        if cmp_result == 0:
            return self.__class__([1])
        
        # Определяем максимальную степень для начала деления
        # k_max - это разница в количестве разрядов между делимым и делителем
        # Это позволяет начать деление с правильной позиции
        # Также k_max позволяет определить максимальное количество цифр
        # в результирующем частном.
        k_max = len(self.digits) - len(second.digits)
        
        # Копируем делимое - это будет остаток, который мы будем уменьшать
        remainder = self.copy()
        result_digits = []  # Массив цифр результата (частного)
        
        # Проходим по всем позициям от старшей (k_max) до младшей (0)
        # Это соответствует алгоритму деления "в столбик" слева направо
        for k in range(k_max, -1, -1):
            # Находим цифру частного на позиции k
            # DIV_NN_DK находит максимальную цифру d, такую что
            # (second * 10^k * d) <= remainder
            digit = remainder.DIV_NN_DK(second, k)
            
            # Если найденная цифра > 0, вычитаем соответствующее произведение из остатка
            if digit > 0:
                # Сдвигаем делитель влево на k позиций (умножаем на 10^k)
                shifted = second.MUL_Nk_N(k)
                # Умножаем сдвинутый делитель на найденную цифру
                product = shifted.MUL_ND_N(digit)
                # Вычитаем произведение из остатка
                remainder = remainder.SUB_NN_N(product)
            
            # Пропускаем ведущие нули (не добавляем их в начало результата)
            if len(result_digits) == 0 and digit == 0:
                continue
            
            # Добавляем найденную цифру в результат
            result_digits.append(digit)
        
        # Удаляем ведущие нули из результата (если они остались)
        # Это может произойти, если все цифры на старших позициях были нулями
        while len(result_digits) > 1 and result_digits[0] == 0:
            result_digits.pop(0)
        
        # Возвращаем частное как новое натуральное число
        return self.__class__(result_digits)