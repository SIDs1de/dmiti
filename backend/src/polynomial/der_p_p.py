from typing import Self
from src.rational import Rational
from src.integer import Integer
from src.natural import Natural

class DER_P_P:
    def DER_P_P(self) -> Self:
        """
        Метод нахождения производной многочлена
        Результат - многочлен
        Автор: Рубан Егор гр. 4383
        
        Параметры:
            self: Self - исходный многочлен
        
        Возвращает:
            Self - производная многочлена
        
        Алгоритм:
            Вычисляет производную многочлена по правилу дифференцирования:
            d/dx(a_n*x^n + a_(n-1)*x^(n-1) + ... + a_1*x + a_0) =
            = n*a_n*x^(n-1) + (n-1)*a_(n-1)*x^(n-2) + ... + 1*a_1
            
            Для каждого члена многочлена a_i*x^i:
            1. Если i == 0 (константный член), пропускаем его (производная = 0)
            2. Новая степень: i - 1
            3. Новый коэффициент: a_i * i (коэффициент умножается на старую степень)
            4. Добавляем новый член в результирующий многочлен
        
        Математически:
            Если P(x) = Σ(a_i * x^i) для i от 0 до n,
            то P'(x) = Σ(i * a_i * x^(i-1)) для i от 1 до n
        
        Примеры:
            DER_P_P({2: 3, 1: 2, 0: 1}) = {1: 6, 0: 2}
            (3x^2 + 2x + 1)' = 6x + 2
            
            DER_P_P({3: 1, 0: 5}) = {2: 3}
            (x^3 + 5)' = 3x^2
            
            DER_P_P({0: 7}) = {0: 0}
            (7)' = 0
        
        Используется в:
            - NMR_P_P (преобразование многочлена - кратные корни в простые)
        
        Примечание:
            - Производная константы (многочлена степени 0) равна нулю
            - Производная многочлена степени n имеет степень n-1 (или 0, если n=0)
            - Коэффициенты умножаются на степень, поэтому используются рациональные числа
        """
        # Получаем степень многочлена
        n = self.m

        # Если многочлен является константой (степень 0), производная равна нулю
        if n == 0:
            zero = Rational(Integer(0, Natural([0])), Natural([1]))
            return self.__class__({0: zero})

        # Словарь для хранения коэффициентов производной
        new_coeffs = {}

        # Проходим по всем коэффициентам исходного многочлена
        # i - степень, coef - коэффициент при x^i
        for i, coef in self.coefficients.items():
            # Пропускаем константные члены (i == 0), так как их производная равна 0
            # Производная константы: d/dx(a_0) = 0
            if i == 0:
                continue
            
            # Новая степень после дифференцирования: i -> i-1
            # Например, производная от x^3 -> 3x^2 (степень уменьшается на 1)
            degree = i - 1
            
            # Преобразуем степень i в натуральное число для умножения
            # Это нужно, так как коэффициенты - рациональные числа,
            # и мы должны умножить коэффициент на степень i
            if i == 0:
                # Этот блок недостижим из-за проверки выше, но оставлен для ясности
                power = Natural([0])
            else:
                # Преобразуем целое число i в натуральное число
                # Разбиваем i на цифры
                digits = []
                temp = i
                while temp > 0:
                    digits.insert(0, temp % 10)  # Добавляем цифру в начало
                    temp //= 10
                power = Natural(digits)
            
            # Создаем рациональное число из степени i
            # Integer(0, power) - положительное целое число (знак 0)
            # Natural([1]) - знаменатель равен 1
            rat_degree = Rational(Integer(0, power), Natural([1]))

            # Умножаем коэффициент на степень: новый_коэффициент = старый_коэффициент * i
            # Это соответствует правилу: d/dx(a*x^i) = i*a*x^(i-1)
            new_coef = coef.MUL_QQ_Q(rat_degree)
            
            # Сохраняем новый коэффициент с новой степенью
            new_coeffs[degree] = new_coef

        # Возвращаем новый многочлен - производную исходного
        return self.__class__(new_coeffs)