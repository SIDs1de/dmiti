from typing import Self

class Add_zz_z:
    def add_zz_z(self: Self, second: Self) -> Self:
        """
        Приготовил: Viktor Permitin
        Сложение целых чисел
        
        Параметры:
            self: Self - первое целое число (слагаемое)
            second: Self - второе целое число (слагаемое)
        
        Возвращает:
            Self - сумма двух целых чисел (self + second)
        
        Алгоритм:
            Выполняет сложение целых чисел с учетом знаков.
            
            Определяет знаки обоих чисел с помощью poz_z_d():
            - 2 - положительное число
            - 0 - ноль
            - 1 - отрицательное число
            
            Обрабатывает следующие случаи:
            1. Если одно из слагаемых равно нулю, возвращает другое слагаемое
            2. Если знаки одинаковые (оба положительные или оба отрицательные):
               - Складываем абсолютные значения
               - Присваиваем общий знак результату
            3. Если знаки разные (одно положительное, другое отрицательное):
               - Находим большее по модулю число
               - Вычитаем меньшее из большего (по модулю)
               - Присваиваем знак большего по модулю числа
        
        Примеры:
            add_zz_z(5, 3) = 8
            add_zz_z(-5, -3) = -8
            add_zz_z(5, -3) = 2
            add_zz_z(-5, 3) = -2
            add_zz_z(5, 0) = 5
            add_zz_z(0, -3) = -3
        
        Используется в:
            - SUB_ZZ_Z (вычитание через сложение с противоположным числом)
            - ADD_QQ_Q (сложение рациональных чисел)
        
        Примечание:
            Метод работает с длинными целыми числами, представленными как
            знак (0 - плюс, 1 - минус) и абсолютное значение (натуральное число).
        """
        # Определяем знаки обоих чисел
        # poz_z_d возвращает: 2 - положительное, 0 - ноль, 1 - отрицательное
        first_sign = self.poz_z_d()
        second_sign = second.poz_z_d()
        
        # Если первое слагаемое равно нулю, возвращаем второе
        if first_sign == 0:
            return self.__class__(second.sign, second.absolute.copy())
        
        # Если второе слагаемое равно нулю, возвращаем первое
        if second_sign == 0:
            return self.__class__(self.sign, self.absolute.copy())
        
        # Проверяем, одинаковые ли знаки у слагаемых
        is_sum = first_sign == second_sign
        result = None
        
        if is_sum:
            # Случай 1: Оба числа одного знака (оба положительные или оба отрицательные)
            # Складываем абсолютные значения
            result = self.__class__(0, self.absolute.ADD_NN_N(second.absolute))
            
            # Если оба числа отрицательные, результат тоже отрицательный
            if first_sign == 1:
                result = result.mul_zm_z()  # Умножаем на -1
        else:
            # Случай 2: Числа разных знаков (одно положительное, другое отрицательное)
            # Находим большее и меньшее по модулю
            max_number, min_number = self.absolute, second.absolute
            max_number_sign = first_sign  # Знак большего по модулю числа
            
            # Если второе число по модулю больше первого, меняем их местами
            if max_number.COM_NN_D(min_number) == 1:
                max_number, min_number = min_number, max_number
                max_number_sign = second_sign
            
            # Вычитаем меньшее из большего (по модулю)
            result = self.__class__(0, max_number.SUB_NN_N(min_number))
            
            # Присваиваем знак большего по модулю числа
            if max_number_sign == 1:
                result = result.mul_zm_z()  # Умножаем на -1
        
        return result
